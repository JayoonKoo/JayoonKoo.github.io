<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"jayoonkoo.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="티끌모아 태산">
<meta property="og:url" content="https://jayoonkoo.github.io/page/2/index.html">
<meta property="og:site_name" content="티끌모아 태산">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="JayoonKoo">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://jayoonkoo.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>티끌모아 태산</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">티끌모아 태산</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">작은 조각 모음</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">21</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">17</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">156</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JayoonKoo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/JayoonKoo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;JayoonKoo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rnwkdbs12@gmail.com" title="E-Mail → mailto:rnwkdbs12@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/JayoonKoo" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/typeScript/210824-generic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/typeScript/210824-generic/" class="post-title-link" itemprop="url">generic</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 12:06:36 / Modified: 12:07:33" itemprop="dateCreated datePublished" datetime="2022-03-28T12:06:36+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/typeScript/" itemprop="url" rel="index"><span itemprop="name">typeScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="generic"><a href="#generic" class="headerlink" title="generic"></a>generic</h1><h2 id="generic-과-any-에-다른점"><a href="#generic-과-any-에-다른점" class="headerlink" title="generic 과 any 에 다른점"></a>generic 과 any 에 다른점</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloString</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloNumber</span>(<span class="params">message: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입만 다르고 로직은 같은 함수가 반복된다면 ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">message: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 같은 로직이면 문자로 생각하고 싶지만 any가 나옴</span></span><br><span class="line"><span class="comment">// lnegth 같은 메서드를 사용해도 number 가 아니라 any가 나옴..</span></span><br><span class="line"><span class="built_in">console</span>.log(hello(<span class="string">&quot;Mark&quot;</span>));</span><br><span class="line"><span class="comment">// 같은 로직이면 숫자로 생각하고 싶지만..</span></span><br><span class="line"><span class="built_in">console</span>.log(hello(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 string을 넣으면 T 가 string이 되는 것. 마치 변수처럼 사용</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloGeneric</span>&lt;<span class="title">T</span>&gt;(<span class="params">message: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리턴 타입은 &#x27;Mark&#x27;로 추정함.. 리터럴 타입으로</span></span><br><span class="line"><span class="built_in">console</span>.log(helloGeneric(<span class="string">&quot;Mark&quot;</span>).length);</span><br><span class="line"><span class="comment">// 리턴 타입을 27로 추정함.</span></span><br><span class="line"><span class="built_in">console</span>.log(helloGeneric(<span class="number">27</span>));</span><br><span class="line"><span class="comment">// true로 추정함.</span></span><br><span class="line"><span class="built_in">console</span>.log(helloGeneric(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>제너릭 타입을 사용하면 함수 안에서 동적으로 받은 타입을 변수처럼 사용할 수 있다. 이를 활용하여 리턴 타입을 명시 하는지에 기능을 사용할 수 있다.</p>
<h2 id="generic-basic"><a href="#generic-basic" class="headerlink" title="generic basic"></a>generic basic</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloBasic</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">message: T, coment: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용법</span></span><br><span class="line"><span class="comment">// T 는 string U 는 27</span></span><br><span class="line">helloBasic&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&quot;mark&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="comment">// T 는 27 , U 39</span></span><br><span class="line">helloBasic(<span class="number">27</span>, <span class="number">39</span>);</span><br></pre></td></tr></table></figure>

<p>사용할 때에는 두가지 방법으로 사용 가능하다.</p>
<ol>
<li><code>&lt;&gt;</code> 안에 타입 명시 -&gt; 이렇게 하면 매개변수로 주는 타입을 명시한 터입으로 지정해야 한다.</li>
<li>평범하게 사용, 이렇게 하면 타입스크립트가 추론해서 타입을 정하게 된다. 일반적으로 27과 같은 숫자를 넣으면 number 라고 생각할 수 도 있지만, 타입 스크립트는 타입을 가능한 좁게 가져가기 때문에 타입은 number 가 아니라 27이 된다.</li>
</ol>
<h2 id="generics-array-amp-tuple"><a href="#generics-array-amp-tuple" class="headerlink" title="generics array &amp; tuple"></a>generics array &amp; tuple</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloArray</span>&lt;<span class="title">T</span>&gt;(<span class="params">message: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T는 string으로 추론됨.</span></span><br><span class="line">helloArray([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]);</span><br><span class="line"><span class="comment">// T는 &lt;string | number&gt; 로 추론함. 유니온 타입이됨.</span></span><br><span class="line"><span class="comment">// string과 number 에서 모두 사용할수 있는 메서드만 사용할 수 있음.</span></span><br><span class="line">helloArray([<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloTuple</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">message: [T, K]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> message[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string 이 리턴 타입</span></span><br><span class="line">helloTuple([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>]);</span><br><span class="line"><span class="comment">// 리턴 타입이 정확하게 string으로 추정됨.</span></span><br><span class="line">helloTuple([<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>제너릭에서 배열과 튜플을 활용하는 방법은 다음과 같다. 이때 어떤 타입에 데이터가 인수로 들어올지 알 수 있다면 튜플로 사용하는것이 타입을 더 명시적으로 관리할 수 있다.</p>
<h2 id="generic-function"><a href="#generic-function" class="headerlink" title="generic function"></a>generic function</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> helloFunctionGeneric1 = &lt;T&gt;<span class="function">(<span class="params">message: T</span>) =&gt;</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloFuncion1: helloFunctionGeneric1 = &lt;T&gt;(message: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> helloFunctionGeneric2 &#123;</span><br><span class="line">  &lt;T&gt;(message: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helloFunction2: helloFunctionGeneric2 = &lt;T&gt;(message: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수에서도 동일하게 generic 을 사용할 수 있다.</p>
<h2 id="generic-class"><a href="#generic-class" class="headerlink" title="generic class"></a>generic class</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스 전체에서 T는 유효범위를 갖는다.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _name: T;</span><br><span class="line">  <span class="keyword">private</span> _age: K;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: T, age: K</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">    <span class="built_in">this</span>._age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">&quot;Mark&quot;</span>, <span class="number">39</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&quot;koo&quot;</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<h2 id="generic-with-extends"><a href="#generic-with-extends" class="headerlink" title="generic with extends"></a>generic with extends</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonExtends</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">string</span> | <span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _name: T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: T</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PersonExtends(<span class="string">&quot;Mark&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> PersonExtends(<span class="number">27</span>);</span><br><span class="line"><span class="comment">// new PersonExtends(true);</span></span><br></pre></td></tr></table></figure>

<p>generic 에서 extends 는 일반적인 상속과는 다른 개념으로 사용된다. generic 에서 사용하게 되면 타입을 제한하는 역활을 하게 된다. 따라서 코드에서 <code>new PersonExtends(true)</code>는 에러를 인수로 <code>&lt;string | number &gt;</code> 가 아닌 값을 주었기 때문에 에러를 발생시킨다.</p>
<h2 id="keyof-amp-type-lookup-system"><a href="#keyof-amp-type-lookup-system" class="headerlink" title="keyof &amp; type lookup system"></a>keyof &amp; type lookup system</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person: IPerson = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;mark&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">39</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key 이름으로 된 유니온 타입이 반환된다.</span></span><br><span class="line"><span class="keyword">type</span> Keys = keyof IPerson;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리턴 타이에도 문제가 생김...</span></span><br><span class="line"><span class="comment">// IPerson[keyof IPerson]</span></span><br><span class="line"><span class="comment">// =&gt; IPerson[&quot;name&quot; | &quot;age&quot;]</span></span><br><span class="line"><span class="comment">// =&gt; IPerson[&quot;name&quot;] | IPerson[&quot;age&quot;]</span></span><br><span class="line"><span class="comment">// =&gt; string | number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key 가 name 일 때 string</span></span><br><span class="line"><span class="comment">// key 가 age 일 때 number</span></span><br><span class="line">getProp(person, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProp</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K, value: T[K]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 경우에 따라서 넣어야 하는 타입이 달라지기 때문에</span></span><br><span class="line">  obj[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setProp(person, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;koo&quot;</span>);</span><br><span class="line">setProp(person, <span class="string">&quot;age&quot;</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure>

<p><code>keyof</code> 를 사용하면 인터페이스에 key로 구성된 유니온 타입을 반환한다. 어떤 매개변수끼리 혹은 리턴 값 끼리 서로 관련 성이 있어서 타입이 달라지는 경우 <code>keyof</code>와 <code>extends</code>를 활용하여 관계성을 정의할 수 있다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/Material%20Designe/220328-Layout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/Material%20Designe/220328-Layout/" class="post-title-link" itemprop="url">Layout</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 12:05:45 / Modified: 12:07:59" itemprop="dateCreated datePublished" datetime="2022-03-28T12:05:45+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MaterialDesigne/" itemprop="url" rel="index"><span itemprop="name">MaterialDesigne</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h1><p>플랫폼, 환경 및 화면 크기 전반에 걸쳐 일관성을 유지하기 위한 균일한 요소와 간격에 대해서..</p>
<h2 id="Principles"><a href="#Principles" class="headerlink" title="Principles"></a>Principles</h2><ul>
<li>예측 가능성. 일관된 UI 영역 및 공간 구성으로 직관적이고 예측 가능으한 레이웃이여야 한다.</li>
<li>일관성</li>
<li>반응성</li>
</ul>
<h2 id="Layout-anatomy"><a href="#Layout-anatomy" class="headerlink" title="Layout anatomy"></a>Layout anatomy</h2><p>레이아웃은 유사한 기능ㅇ을 공유하는 요서와 구성 요서로 구성된다. 레이아웃 영역은 또한 작은 컨테이너를 그룹화 한다.</p>
<p>큰 화면 레이아웃에는 세 가지 주요 영역이 있다. </p>
<img src="images/220328_Layout/1.png" widht="400" />

<ol>
<li>App bars</li>
<li>Navigation</li>
<li>Body</li>
</ol>
<p>반응형을 구현할때는 작은 화면에서 큰 화면으로 만들어 가면서 다양한 form factors 에 적용해 나가는 것이 좋다. </p>
<h3 id="Body-region"><a href="#Body-region" class="headerlink" title="Body region"></a>Body region</h3><p>Body 영역은 대부분의 컨텐트를 표시하는데 사용된다. 일반적으로 목록, 카드, 버튼 및 이미지와 같은 구성 요소를 포함한다.</p>
<p>Body 영역은 세가지 매개변수에 대한 확장 가능한 값을 갖는다.</p>
<ol>
<li>Vertical and horizontal dimensions</li>
<li>Number of Columns</li>
<li>Margins</li>
</ol>
<h3 id="Responsive-column-grid"><a href="#Responsive-column-grid" class="headerlink" title="Responsive column grid"></a>Responsive column grid</h3><p>화면 크기에 따른 break point</p>
<img src="images/220328_Layout/2.png" widht="400" />

<h3 id="Navigation-region"><a href="#Navigation-region" class="headerlink" title="Navigation region"></a>Navigation region</h3><p>네비게이션 서랍이나 목록을 표시하는 영역이다. 네비게이션 영역의 넓이는 확장되었을때는 256dp 접었을때는 72dp (rail)를 유지한다. margin 이 48dp 보다 적은 화면 사이즈에서는 body navigation 영역을 보여주기 위해서 body 영역이 줄어들 수 있다. (600~904dp 사이에 영역)</p>
<img src="images/220328_Layout/3.png" widht="400" />

<p>만약 화면 사이즈가 600dp 보다 작다면 modal 를 사용한다. </p>
<img src="images/220328_Layout/4.png" widht="400" />

<h3 id="App-bar"><a href="#App-bar" class="headerlink" title="App bar"></a>App bar</h3><p>앱바는 사용자가 기본 작업을 수행하거나 본문 영역의 요소에 대해 작업을 수행하는 데 도움이 되는 구성 요소 및 작업을 표시하고 그룹화하는 데 사용된다. </p>
<h2 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h2><h3 id="Visual-grouping"><a href="#Visual-grouping" class="headerlink" title="Visual grouping"></a>Visual grouping</h3><p>유사한 콘텐츠 또는 기능을 가진 레이아웃의 요소는 그룹화하여 다른 요소와 분리한다. </p>
<img src="images/220328_Layout/5.png" widht="400" />

<p>글자 영역에 빈공간을 사용하여 다른 요소와 분리한다.</p>
<h3 id="Containment"><a href="#Containment" class="headerlink" title="Containment"></a>Containment</h3><p>관련된 요소끼리 가깝게 배치하고 관련 되지 않는 요소 끼리는 넓게 배치하여 두 그룹을 분리 할 수 있고, 선을 이용하여 분리할 수도 있다. </p>
<img src="images/220328_Layout/6.png" widht="400" />

<p>텍스트를 포함하는 컨텐츠는 사이즈가 쉽게 변해야 하며, 읽기 쉬운 상태로 남아있어야 한다. </p>
<h3 id="Scaling-with-text"><a href="#Scaling-with-text" class="headerlink" title="Scaling with text"></a>Scaling with text</h3><p>한줄에 40-60 글자가 있는 것이 이상적이다. 텍스트를 포함된 요소는 가독성을 유지하면서 요소 크기에 맞춰 크기를 조정해야 한고 한줄에 너무 길게 확장되지 않도록 해야한다. </p>
<p>가독성을 높이려면 line height 를 조정하는것이 좋다. </p>
<h2 id="Material-measurements"><a href="#Material-measurements" class="headerlink" title="Material measurements"></a>Material measurements</h2><p>시각적 균형을 이루도록 하기 위해 대부분의 간격과 레이아웃 모두에 8dp로 정렬한다. 구성 요소의 크기는 8dp 단위로 조정되어 각 화면에서 일관된 시각적 리듬을 보장한다. 또한 아이콘, 텍스트와 같은 더 작은 요소는 4dp 기준으로 정렬할 수 있다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Exception%20filters/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Exception%20filters/" class="post-title-link" itemprop="url">Exception filters</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h1><p>Nest 에는 애플리케이션 전체에서 처리되지 않은 모든 예외를 처리하는 레이어가 내장되어 있다. 처리 되지 않은 예외가 여기에서 잡힌다. </p>
<p>기본적으로 이 작업은 HttpException 유형의 예외를 처리하는 내장 전역 예외 필터에 의해 수행된다.</p>
<p>예외가 인식되지 않는 경우(HttpException 도 아니고, HttpException에서 상속한 클래스도 아님) 기본 제공 예외 필터는 다음과 같은 기본 JSON 응답을 새성한다. </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;statusCode&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Internal server error&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http-erros 라이브러를 사용한다. 기본적으로 statusCode와 message 가 채워져서 응답으로 보내진다. </p>
<h2 id="Throwing-standard-exceptions"><a href="#Throwing-standard-exceptions" class="headerlink" title="Throwing standard exceptions"></a>Throwing standard exceptions</h2><p>Nest 는 HttpException class 를 내장해서 사용한다. 컨틀롤러에서 에러를 발생시키는 예시 코드를 만들어 보자.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Get()</span><br><span class="line">async findAll() &#123;</span><br><span class="line">  throw new HttpException(&#x27;Forbidden&#x27;, HttpStatus.FORBIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클라이언트가 해당 엔드포인트를 호출하면 다음 json을 반환한다. </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;statusCode&quot;</span>: <span class="number">403</span>,</span><br><span class="line">  <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;Forbidden&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpException 은 response 와 status 를 받는데 response 는 string이나 객체가 올 수 있고, status 는 HTTP status code 를 사용한다. response에 객체를 넘겨주면, serialize 해서 반환해 준다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Get()</span><br><span class="line">async findAll() &#123;</span><br><span class="line">  throw new HttpException(&#123;</span><br><span class="line">    status: HttpStatus.FORBIDDEN,</span><br><span class="line">    error: &#x27;This is a custom message&#x27;,</span><br><span class="line">  &#125;, HttpStatus.FORBIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>반환하는 JSON : </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;status&quot;</span>: <span class="number">403</span>,</span><br><span class="line">  <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;This is a custom message&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Custom-exceptions"><a href="#Custom-exceptions" class="headerlink" title="Custom exceptions"></a>Custom exceptions</h2><p>대부분의 경우 custom exceptions를 사용할 일이 없지만 사용하고 싶다면 HttpException을 상속하는 예외 클래스를 커스텀 할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export class ForbiddenException extends HttpException &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super(&#x27;Forbidden&#x27;, HttpStatus.FORBIDDEN);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpException 을 상속하였기 때문에 동일하게 동작하여 동일하게 사용할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Get()</span><br><span class="line">async findAll() &#123;</span><br><span class="line">  throw new ForbiddenException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Built-in-HTTP-exceptions"><a href="#Built-in-HTTP-exceptions" class="headerlink" title="Built-in HTTP exceptions"></a>Built-in HTTP exceptions</h2><p>Nest는 기본 ThhpException에서 상속되는 일련의 표준 예외를 제공한다. </p>
<h2 id="Exception-filters-1"><a href="#Exception-filters-1" class="headerlink" title="Exception filters"></a>Exception filters</h2><p>Exception filters 는 에러에대한 컨트롤을 위해서 디자인되었다. 다음은 HttpException 인스턴스 예외를 포착하고 이데 대응하는 사용자 응답을 구현하는 예외 필터를 만들어 본다. </p>
<p>이를 위해서는 Request와 Response가 필요하고 Request에서 url 을 가져와 logging을 만들고 Response.json() 메서드를 사용하여 응답되는 데이터를 직접 제어해 본다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ExceptionFilter, Catch, ArgumentsHost, HttpException &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Request, Response &#125; from &#x27;express&#x27;;</span><br><span class="line"></span><br><span class="line">@Catch(HttpException)</span><br><span class="line">export class HttpExceptionFilter implements ExceptionFilter &#123;</span><br><span class="line">  catch(exception: HttpException, host: ArgumentsHost) &#123;</span><br><span class="line">    const ctx = host.switchToHttp();</span><br><span class="line">    const response = ctx.getResponse&lt;Response&gt;();</span><br><span class="line">    const request = ctx.getRequest&lt;Request&gt;();</span><br><span class="line">    const status = exception.getStatus();</span><br><span class="line"></span><br><span class="line">    response</span><br><span class="line">      .status(status)</span><br><span class="line">      .json(&#123;</span><br><span class="line">        statusCode: status,</span><br><span class="line">        timestamp: new Date().toISOString(),</span><br><span class="line">        path: request.url,</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>모든 예외 필터는 ExceptionFilter<T> 제너릭으로 구현해야 한다. catch에 exception type으로 제너링 타입을 사용한다. <code>catch(exception: T, host: ArgumetnHost)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Guards/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Guards/" class="post-title-link" itemprop="url">Guards</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h1><p>Guard 는 CanActivate 인터페이스를 구현하는 @Injectable() 데코레이터가 달린 클래스이다. </p>
<p>Guard 는 request 가 실행 가능한지 여부를 판단한다. 흔히 이것을 authorization이라고 부르며 Express 에서는 대부분 midlleware 에서 처리하여 특정 컨트롤러와 강하게 연결되는것을 막았다. </p>
<p>그러나 middleware 에 가장 큰 문제는 next 이후에  어떤 함수가 실행되는지 모른다는 것에 있다. Guard 는 ExecutionContext 를 알수 있고 request/response 싸이클에 선언적으로 사용할 수 있어서 코드를 더 읽기좋고 선언적으로 만들어 준다. </p>
<p>Guard 는 각 미들웨어 이후에 실행되지만 인터셉터나 파이프 이전에 실행된다. </p>
<h2 id="Authorization-Guard"><a href="#Authorization-Guard" class="headerlink" title="Authorization Guard"></a>Authorization Guard</h2><p>Authorization 은 Guard 에 가장 좋은 예이다. AuthGuard 는 request 에서 토큰을 추출하고 판단한 후 다음 과정을 진행할지 판단하게 할 수 있다. </p>
<p>auth.guard.ts : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, CanActivate, ExecutionContext &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class AuthGuard implements CanActivate &#123;</span><br><span class="line">  canActivate(</span><br><span class="line">    context: ExecutionContext,</span><br><span class="line">  ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123;</span><br><span class="line">    const request = context.switchToHttp().getRequest();</span><br><span class="line">    return validateRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Guard 는 canActivate() 를 구현하고 request를 넘길지 여부를 boolean 으로 반환한다. 또한, Promise , Observable를 반환할 수 있기 때문에 동기적으로나 비동기 적으로나 반환하는것이 가능하다. </p>
<h2 id="Execution-context"><a href="#Execution-context" class="headerlink" title="Execution context"></a>Execution context</h2><p>canActivate 는 ExecutionContext 인스턴스를 받고 ExecutionContext 는 ArgumetnsHost 를 상속한다. context 변수를 통하여 request 를 얻을 수 있다. </p>
<h2 id="Role-based-authentication"><a href="#Role-based-authentication" class="headerlink" title="Role-based authentication"></a>Role-based authentication</h2><p>특정 권한을 가진 유저만 허용하는 Guard 를 만들어 보자. 지금은 template 로서 모든 권한을 허용하고 추후에 기능을 추가하면서 role 기반 authentication 을 만들어 본다. </p>
<p>roles.guard.ts : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, CanActivate, ExecutionContext &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class RolesGuard implements CanActivate &#123;</span><br><span class="line">  canActivate(</span><br><span class="line">    context: ExecutionContext,</span><br><span class="line">  ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binding-guards"><a href="#Binding-guards" class="headerlink" title="Binding guards"></a>Binding guards</h2><p>guard 는 exception filter 와 마찬가지로 controller-scoped, method-scoped, global-scoped 모두 가능하다. 다음은 @UseGuards() 데코레이터를 이용하여 controller-scoped 로 사용한 예제이다. 해당 데코레이터는 단일 인수나 쉼표로 구분하여 인수를 받을 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Controller(&#x27;cats&#x27;)</span><br><span class="line">@UseGuards(RolesGuard)</span><br><span class="line">export class CatsController &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>내부 인스턴스를 전달할 수도 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Controller(&#x27;cats&#x27;)</span><br><span class="line">@UseGuards(new RolesGuards())</span><br><span class="line">export class CatsController &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>만약 method-scoped 로 사용하고 싶다면 UseGuards 데코레이터를 메서드 레벨에서 사용한다. 글로벌로 사용하고 싶다면 nest application 인스턴스에  useGlobalGuards() 메서드를 사용한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app = await NestFactory.create(AppModule);</span><br><span class="line">app.useGlobalGuards(new RolesGuard());</span><br></pre></td></tr></table></figure>

<p>의존성 주입 측면에서 모듈 밖에서 useGlobalGuards() 메서드에 의해서 등록되므로 의존성을 주입할 수 없다. 이런 문제를 해결하기 위해서 module 주입해서 사용할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Module(&#123;</span><br><span class="line">	providers: [</span><br><span class="line">		&#123;</span><br><span class="line">			provide: APP_GUARD,</span><br><span class="line">			useClass: RolesGuard,</span><br><span class="line">		&#125;,</span><br><span class="line">	],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Setting-roles-per-handler"><a href="#Setting-roles-per-handler" class="headerlink" title="Setting roles per handler"></a>Setting roles per handler</h2><p>위에서 작성한 roleguard 는 지금 어떤 권한도 확인하지 않고 있다. 권한을 확인하는 가장 좋은 방법은 metadata를 활용하는 것이다. nest 는 custom meataData 를 첨부하는 @SetMetadata() 데코레이터를 제공한다. </p>
<p>cats.controller.ts : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@SetMetadata(&#x27;roles&#x27;, [&#x27;admin&#x27;])</span><br><span class="line">async create(@Body() createCatDto: CreateCatDto) &#123;</span><br><span class="line">	this.catService.create(createCatDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>이것이 작동하는 동안 경로에서 직접 @SetMetadata() 를 사용하는 것은 좋은 습관이 아니다. 대신 custom decorator 를 사용하도록 한다. </p>
<p>roles.decorators.ts : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; SetMetadata &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line"></span><br><span class="line">export const Roles = (...roles: string[]) =&gt; SetMetadata(&#x27;roles&#x27;, roles);</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 읽기 쉽고 타입을 알 수 있는 custom decorator 가 만들어 진다. 사용은 다음과 같이 한다. </p>
<p>cats.controller.ts : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Post()</span><br><span class="line">@Roles(&#x27;admin&#x27;)</span><br><span class="line">async create(@Body() createCatDto:CreateCatDto) &#123;</span><br><span class="line">	this.catService.create(createCatDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Putting-in-all-together"><a href="#Putting-in-all-together" class="headerlink" title="Putting in all together"></a>Putting in all together</h2><p>Guard 에 적용해보자. 먼저 권한 정보를 알아야하는데 우리는 metadata 를 통해서 권한정보를 첨부했다. 권한 정보에 접근 하기 위해서는 Reflector hleper class 를 사용한다. </p>
<p>roles.guard.ts :</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Interceptors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Interceptors/" class="post-title-link" itemprop="url">Interceptors</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h1><p><code>NestInterceptor</code> 인터페이스를 구현하고 <code>@Injectable()</code> 데코레이터가 어노테이션으로 붙는 클래스이다. </p>
<p>interceptor 는 AOP 관점에서 탁월한 능력을 몇가지 갖고 있다. </p>
<ul>
<li>method 가 실행되기 전과 후에 외부 로직을 bind 할 수 있다.</li>
<li>함수에 return 을 변형시킬 수 있다.</li>
<li>함수에 예외를 변형시킨다.</li>
<li>함수에 기본동작을 확장한다.</li>
<li>특정 조건에 따라 완전히 함수를 오버라이딩 할 수 있다.</li>
</ul>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>Interceptor 는 <code>intercept()</code> 메서드를 구현한다. <code>intercept()</code> 메서드는 두개의 매개변수를 갖는다. 하나는 <code>ExecutionContext</code> 인스턴이다( guard 와 정확히 같은 객체). <code>ExecutionContext</code> 는 <code>ArgumentsHost</code> 를 상속한다. 두번째 매개변수는 <code>Call handler</code> 이다. </p>
<h3 id="Execution-context"><a href="#Execution-context" class="headerlink" title="Execution context"></a>Execution context</h3><p><code>ArgumentHost</code> 를 확장했고, <code>ExecutionContext</code> 는 현재 실행 프로세스를 세부적인 사항을 제공하는 헬퍼 메서드를 추가했다. </p>
<h3 id="Call-handler"><a href="#Call-handler" class="headerlink" title="Call handler"></a>Call handler</h3><p><code>CallHandler</code> 인터페이스는 route handler method 를 interceptor 에 특정 시점에 호출하여 사용할 수 있는 <code>handler()</code> 메서드를 구현한다. 만약 <code>interceptor()</code> 메서드에서 <code>handler()</code> 메서드를 호출하지 않는다면 route handler method 는 실행되지 않을 것이다. </p>
<p>이것은 <code>interceptor()</code> 메서드가 효과적으로 request/response 스트립을 wrap 했다는 것을 의미한다. 결과적으로  route handler method 가 호출되기 전과 후에 호출되는 커스텀 로직을 구현할 수 있게된다. <code>handler()</code> 가 호출되기 전에 로직을 작성하면 route handler method 가 호출되기 전 실행되는 로직을 만들 수 있는 것은 분명한데, 호출된 이후에는 어떻게 알 수 있을까? 답은 <code>handler()</code> 메서드가 <code>Observable</code> 를 반환하기 때문에 알 수 있다. <code>RxJs</code> 기능을 사용하여 응답을 조작하는 작업을 할 수 있다. AOP 관점에서 <code>handler()</code> 메서드는 추가 로직이 추가되어야 하는 지점을 나타내는 <code>Pointcut</code> 이라고 불린다.</p>
<p><code>handler()</code> 가 호출되는 시점에서 Controller 에 메서드가 트리거 되고 <code>Observable</code> 를 반환하기 때문에 stream 안에서 추가작인 작업을 수행할 수 있다. </p>
<h2 id="Aspect-interception"><a href="#Aspect-interception" class="headerlink" title="Aspect interception"></a>Aspect interception</h2><p>첫번째 use case 는 사용자의 intercation을 로그로 남기는 LoggingInterceptor 이다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">import &#123; tap &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class LoggingInterceptor implements NestInterceptor &#123;</span><br><span class="line">  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    console.log(&#x27;Before...&#x27;);</span><br><span class="line"></span><br><span class="line">    const now = Date.now();</span><br><span class="line">    return next</span><br><span class="line">      .handle()</span><br><span class="line">      .pipe(</span><br><span class="line">        tap(() =&gt; console.log(`After... $&#123;Date.now() - now&#125;ms`)),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NestInterceptor&lt;T,R&gt;</code> 는 generic interface 이다. T 는 응답 스트림 <code>Observable&lt;T&gt;</code> R 은 Wrapping 된 <code>Observable&lt;R&gt;</code> 을 나타낸다. </p>
<p>interceptors 또한, constructor 를 통해서 주입될 수 있다. </p>
<h2 id="Binding-interceptors"><a href="#Binding-interceptors" class="headerlink" title="Binding interceptors"></a>Binding interceptors</h2><p>인터셉터를 세팅하기 위해서 <code>@UseInterceptors()</code> 를 사용한다. <code>pipes</code> 나 <code>guards</code> 와 마찬가지로 controller-scoped, method-scoped, global-scoped 모두 가능하다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@UseInterceptors(LoggingInterceptor)</span><br><span class="line">export class CatsController &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>이제 컨트롤러에 요청마다 다음과 같은 로그를 확인할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before...</span><br><span class="line">After... 1ms</span><br></pre></td></tr></table></figure>

<p>위에 예에서 Type을 전달하여 프레임워크에 인스턴스화에 대한 책임을 맡기고 종속성을 주입했다. 또한, 인스턴스를 넘기는 것도 가능하다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@UseInterceptors(new LoggingInterceptor())</span><br><span class="line">export class CatsController&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 레벨에서 설정했기 때문에 모든 메서드마다 Logging 이 실행된다. 만약 특정 함수로 제한하고 싶다면 method 레벨에서 설정해주면 된다. </p>
<p>전역으로 설정하고 싶다면 app 에 <code>useGlobalInterceptors()</code> 를 사용하여 등록해주면 된다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const app = await NestFactory.create(AppModule);</span><br><span class="line">app.useGlobalInterceptors(new LoggingInterceptor());</span><br></pre></td></tr></table></figure>

<p>이렇게 작성하면 dependnecy injection 측면에서 좋지 않기 때문에 module 에 주입하도록 작성할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; APP_INTERCEPTOR &#125; from &#x27;@nestjs/core&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  providers: [</span><br><span class="line">    &#123;</span><br><span class="line">      provide: APP_INTERCEPTOR,</span><br><span class="line">      useClass: LoggingInterceptor,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Response-mapping"><a href="#Response-mapping" class="headerlink" title="Response mapping"></a>Response mapping</h2><p><code>handler()</code> 는 <code>Observable</code> 를 반환한다. 따라서 RxJS 의 <code>map()</code> 기능을 사용할 수 있다. </p>
<p>응답 매핑 기능은 라이브러리별 응답전략에서는 작동하지 않는다. (@Res 에서 작동 안함)</p>
<p>RxJS 의 <code>map</code> 을 사용하여data property 를 응답에 추가해 클라이언트에게 전달하는 <code>TransformInterceptor</code> 를 구현해 보자. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">import &#123; map &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line"></span><br><span class="line">export interface Response&lt;T&gt; &#123;</span><br><span class="line">  data: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; &#123;</span><br><span class="line">  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;Response&lt;T&gt;&gt; &#123;</span><br><span class="line">    return next.handle().pipe(map(data =&gt; (&#123; data &#125;)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nest interceptors 는 동기와 비동기 모두 동작한다. 필요하면 <code>async</code> 키워드를 사용할 수 있다.</p>
<p>interceptor 는 애플리케이션 전체를 가로지르는 좋은 해결책이 된다. 만약 모든 응답에서 null 인 값을 빈 스트링으로 바꿔야 한다고 가정해보자. 이 경우 interceptor 구현하고 전역으로 사용하도록 주입하면 된다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">import &#123; map &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ExcludeNullInterceptor implements NestInterceptor &#123;</span><br><span class="line">  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    return next</span><br><span class="line">      .handle()</span><br><span class="line">      .pipe(map(value =&gt; value === null ? &#x27;&#x27; : value ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exception-mapping"><a href="#Exception-mapping" class="headerlink" title="Exception mapping"></a>Exception mapping</h2><p>RxJS 의 <code>catchError()</code> 를 사용하여 예외를 override 할수도 있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  Injectable,</span><br><span class="line">  NestInterceptor,</span><br><span class="line">  ExecutionContext,</span><br><span class="line">  BadGatewayException,</span><br><span class="line">  CallHandler,</span><br><span class="line">&#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable, throwError &#125; from &#x27;rxjs&#x27;;</span><br><span class="line">import &#123; catchError &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class ErrorsInterceptor implements NestInterceptor &#123;</span><br><span class="line">  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    return next</span><br><span class="line">      .handle()</span><br><span class="line">      .pipe(</span><br><span class="line">        catchError(err =&gt; throwError(() =&gt; new BadGatewayException())),</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream-overriding"><a href="#Stream-overriding" class="headerlink" title="Stream overriding"></a>Stream overriding</h2><p>응답 시간을 줄이기 위해 캐시를 사용해 응답을 완전히 바꾸는 등의 작업도 할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, NestInterceptor, ExecutionContext, CallHandler &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Observable, of &#125; from &#x27;rxjs&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class CacheInterceptor implements NestInterceptor &#123;</span><br><span class="line">  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; &#123;</span><br><span class="line">    const isCached = true;</span><br><span class="line">    if (isCached) &#123;</span><br><span class="line">      return of([]);</span><br><span class="line">    &#125;</span><br><span class="line">    return next.handle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서는 하드 코딩 된 isCached 와 [] 를 사용했지만 중요한 점은 RxJS 의 of 를 사용하여 생성된 스트림을 여기에서 반환하므로 route handler 가 호출되지 않는다는 것이다. 만약 CacheInterceptor 를 사용하는 메서드에서는 응답이 빈 리스트로 바로 반환될 것이다.</p>
<h2 id="More-operators"><a href="#More-operators" class="headerlink" title="More operators"></a>More operators</h2><p>route request 에 timouts 를 주고 싶다고 가정해보자. 일정 기간동안 응답 하지 않으면 error 를 반한하게 한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Middleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Middleware/" class="post-title-link" itemprop="url">Middleware</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h1><p>미들웨어는 라우터 핸들러 전에 호출되는 함수이다. 기본적으로 express 에 middleware 와 동일하다. class 와 function 모두 사용할 수 있고, class 로 선언하는 경우에는 NestMiddleware 인터페이스를 구현해야 한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, NestMiddleware &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; Request, Response, NextFunction &#125; from &#x27;express&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class LoggerMiddleware implements NestMiddleware &#123;</span><br><span class="line">  use(req: Request, res: Response, next: NextFunction) &#123;</span><br><span class="line">    console.log(&#x27;Request...&#x27;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h2><p>미들웨어는 Provider 와 Controller 와 마찬가지로 모듈 내에서 사용 가능한 종속성으로 주입할 수 있다. </p>
<h2 id="Applying-middleware"><a href="#Applying-middleware" class="headerlink" title="Applying middleware"></a>Applying middleware</h2><p>middleware 를 갖는 module 은 NestModule를 구현해야 한다. 데코레이터에서 따로 등록할 수 는 없고, configure() 메서드를 통해 등록한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module, NestModule, MiddlewareConsumer &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; LoggerMiddleware &#125; from &#x27;./common/middleware/logger.middleware&#x27;;</span><br><span class="line">import &#123; CatsModule &#125; from &#x27;./cats/cats.module&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule implements NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(&#x27;cats&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forRoutes 를 두어서 특정 요청에 대한 미들 웨어로 제한할 수도 있다. 원하는 요청에 유형을 참조하기 위해 RequestMethod.GET 과 같이 열거형을 사용한다. 추가적으로 configure() 메서드는 async 키워드 사용이 가능하다.</p>
<h2 id="Route-wildcards"><a href="#Route-wildcards" class="headerlink" title="Route wildcards"></a>Route wildcards</h2><p>패턴 기반의 경로도 지원한다. <code>forRoutes(&#123; path: &#39;ab*cd&#39;, method: RequestMethod.ALL &#125;)</code></p>
<h2 id="Middleware-consumer"><a href="#Middleware-consumer" class="headerlink" title="Middleware consumer"></a>Middleware consumer</h2><p>MidddlewareConsumer 는 helper class이다. midlleware 를 관리하는 내장 메서드를 재공한다. chanid 형태로 호출할 수 있고, forRoutes 는 path, RouteInfo 객체 복수, 단수의 컨트롤러 클래스를 전달할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module, NestModule, MiddlewareConsumer &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; LoggerMiddleware &#125; from &#x27;./common/middleware/logger.middleware&#x27;;</span><br><span class="line">import &#123; CatsModule &#125; from &#x27;./cats/cats.module&#x27;;</span><br><span class="line">import &#123; CatsController &#125; from &#x27;./cats/cats.controller&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule implements NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(CatsController);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply 메서드 또한 여러 인수를 사용하여 여러 middleware 를 지정할 수 있다. </p>
<h2 id="Excluding-routes"><a href="#Excluding-routes" class="headerlink" title="Excluding routes"></a>Excluding routes</h2><p>.exclude() 메서드에 string or RouteInfo 객체를 지정하여 특정 라우터에서는 middleware 를 제거할 수도 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(LoggerMiddleware)</span><br><span class="line">  .exclude(</span><br><span class="line">    &#123; path: &#x27;cats&#x27;, method: RequestMethod.GET &#125;,</span><br><span class="line">    &#123; path: &#x27;cats&#x27;, method: RequestMethod.POST &#125;,</span><br><span class="line">    &#x27;cats/(.*)&#x27;,</span><br><span class="line">  )</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>

<p>exclude() 메서드는 path-to-regexp 패키지를 사용한다. </p>
<h2 id="Functional-middleware"><a href="#Functional-middleware" class="headerlink" title="Functional middleware"></a>Functional middleware</h2><p>함수로도 middleware 를 선언할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Request, Response, NextFunction &#125; from &#x27;express&#x27;;</span><br><span class="line"></span><br><span class="line">export function logger(req: Request, res: Response, next: NextFunction) &#123;</span><br><span class="line">  console.log(`Request...`);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>module 에 적용 : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(logger)</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>

<p>다른 의존성이 없다면 funcional middleware 를 대안으로 생각해봐라. </p>
<h2 id="Multiple-middleware"><a href="#Multiple-middleware" class="headerlink" title="Multiple middleware"></a>Multiple middleware</h2><p>apply()메서드 안에 순차적으로 제공하여 여러 middleware를 등록시킬 수 있다. </p>
<p><code>consumer.apply(cors(), helmet(), logger).forRoutes(CatsController)</code></p>
<h2 id="Global-middleware"><a href="#Global-middleware" class="headerlink" title="Global middleware"></a>Global middleware</h2><p>전역으로 한번에 모든 라우터에서 middleware 를 적용 시키고 싶다면 INestApplication 인스턴스에 use() 메서드를 사용하여 전역으로 등록시킬 수 있다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const app = await NestFactory.create(AppModule);</span><br><span class="line">app.use(logger);</span><br><span class="line">await app.listen(3000);</span><br></pre></td></tr></table></figure>

<p>글로벌 미들웨어에서 DI 컨테이너에 액세스하는것은 불가능하다. app.use() 를 사용할때 functional middleware 를 사용하거나, AppModule 내에서 .forRoutes(’*’) 와 함께 사용할 수 있다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Modules/" class="post-title-link" itemprop="url">Modules</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Moudles"><a href="#Moudles" class="headerlink" title="Moudles"></a>Moudles</h1><p>@Module() 데코레이터는 어플리케이션 구성에 필요한 metadate를 공급한다.</p>
<p>애플리케이션은 최소 한개 이상의 모듈이 존재햐아 하고 구성 요소를 구성하는 효과적인 방법으로 모듈을 사용한다. 아주 작은 애플리케이션이 아닌 일반적인 애플리케이션은 여러가지 모듈을 가진다. </p>
<p>모듈은 provider 를 캡슐화 한다. 즉 현제 모듈의 일부도 아니고 가져온 모듈에서 내보낸 것도 아닌 provider 를 주입하는것은 불가능하다.</p>
<h2 id="Feature-modules"><a href="#Feature-modules" class="headerlink" title="Feature modules"></a>Feature modules</h2><p>생성한 controller와 service 는 어떤 기능에 연관되 있기 때문에 하나의 모듈로 만들어서 관리하는 것이 좋다. netst g module &lt;이름&gt; 으로 모듈을 생성할 수 있다. </p>
<h2 id="Shared-modules"><a href="#Shared-modules" class="headerlink" title="Shared modules"></a>Shared modules</h2><p>nest 에서 모듈은 기본적으로 singletons 이다. 따라서 같은 인스턴스를 다양한 모듈에서 공유할 수 있다. 여러 다른 모듈 간의 특정 모듈에 속해 있는 서비스를 공유하고 싶다면 @Module 데코레이터에서 exports 하여 특정 서비스를 내보내야 한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; CatsController &#125; from &#x27;./cats.controller&#x27;;</span><br><span class="line">import &#123; CatsService &#125; from &#x27;./cats.service&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">  exports: [CatsService]</span><br><span class="line">&#125;)</span><br><span class="line">export class CatsModule &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>CatService 를 내보내서 다른 모듈에서 같은 인스턴스를 사용하도록 한다. </p>
<h2 id="Module-re-exporting"><a href="#Module-re-exporting" class="headerlink" title="Module re-exporting"></a>Module re-exporting</h2><p>특정 모듈을 임포트하고 다시 내보낼수도 있다. CommonModule은 CoreModule로 가져오거나 CoreModule에서 내보내어 이 모듈을 가져오는 다른 모듈에서 사용할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Module(&#123;</span><br><span class="line">  imports: [CommonModule],</span><br><span class="line">  exports: [CommonModule],</span><br><span class="line">&#125;)</span><br><span class="line">export class CoreModule &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h2><p>모듈은 Provider 도 주입할 수 있다. (구성 하기 위한 목적으로 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; CatsController &#125; from &#x27;./cats.controller&#x27;;</span><br><span class="line">import &#123; CatsService &#125; from &#x27;./cats.service&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line">export class CatsModule &#123;</span><br><span class="line">  constructor(private catsService: CatsService) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그러나 순환 참조가 될수 있기 때문에 모듈 자체를 Porivder로 주입하는 것은 불가능하다. </p>
<h2 id="Global-modules"><a href="#Global-modules" class="headerlink" title="Global modules"></a>Global modules</h2><p>모든 곳에서 import 하는 같은 모듈을 계속 import 하는 것은 바보같은 짓이다. 그러나 nest 에서는 Provider를 캡슐화 하기 때문에 Provider 를 가져오지 않고는 다른 곳에서 사용할 수 없다. </p>
<p>어느 곳에서나 접근 가능한 Provider 집합을 제공하려는 경우, @Global 데코레이터를 사용하여 사용해야 한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module, Global &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; CatsController &#125; from &#x27;./cats.controller&#x27;;</span><br><span class="line">import &#123; CatsService &#125; from &#x27;./cats.service&#x27;;</span><br><span class="line"></span><br><span class="line">@Global()</span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">  exports: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line">export class CatsModule &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 모듈을 global-scope 에 있도록 만들 수 있다. 전역 모듈은 일반적으로 루트 또는 코어 모듈에서 한번만 등록해야 한다. 이렇게 등록한 모듈 내에 있는 Provider 는 어떠한 다른 모듈에서 import 모듈에 등록할 필요 없이 inject 할 수 있다. </p>
<h2 id="Dynamic-modules"><a href="#Dynamic-modules" class="headerlink" title="Dynamic modules"></a>Dynamic modules</h2><p>Nest 에서는 쉽게 등록 가능한 모듈을 동적으로 만들 수 있고, Provider를 구성할 수 있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module, DynamicModule &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; createDatabaseProviders &#125; from &#x27;./database.providers&#x27;;</span><br><span class="line">import &#123; Connection &#125; from &#x27;./connection.provider&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  providers: [Connection],</span><br><span class="line">&#125;)</span><br><span class="line">export class DatabaseModule &#123;</span><br><span class="line">  static forRoot(entities = [], options?): DynamicModule &#123;</span><br><span class="line">    const providers = createDatabaseProviders(options, entities);</span><br><span class="line">    return &#123;</span><br><span class="line">      module: DatabaseModule,</span><br><span class="line">      providers: providers,</span><br><span class="line">      exports: providers,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forRoot 메서드는 동기식 또는 비동기식으로 모듈을 반환할 수 있다. </p>
<p>DatabaseModule 는 다음과 같은 방법으로 import 될 수  있다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; DatabaseModule &#125; from &#x27;./database/database.module&#x27;;</span><br><span class="line">import &#123; User &#125; from &#x27;./users/entities/user.entity&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  imports: [DatabaseModule.forRoot([User])],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>동적 모듈을 다시 내보내려면 내보내기 배열에서 forRoot() 메서드 호출을 생략 할 수도 있다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/03/28/BackEnd/220328-Providers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/BackEnd/220328-Providers/" class="post-title-link" itemprop="url">Providers</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-03-28 11:53:37 / Modified: 12:12:43" itemprop="dateCreated datePublished" datetime="2022-03-28T11:53:37+09:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Backend/" itemprop="url" rel="index"><span itemprop="name">Backend</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h1><p>Nest 에는 provider 간의 관계를 해결하는 inversion of control (IOC)가 내장되어 있다.</p>
<h2 id="Optional-providers"><a href="#Optional-providers" class="headerlink" title="Optional providers"></a>Optional providers</h2><p>때때로 설정 객체와 같은 것을 optional provider 로 받을 필요가 있다. 설정이 등록되지 않으면 기본 값을 갖도록 하면 되기때문에 무조건 받을 필요가 없기 때문이다. 이럴때에는 provider에 @Optional 데코레이터를 붙혀서 사용한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, Optional, Inject &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class HttpService&lt;T&gt; &#123;</span><br><span class="line">  constructor(@Optional() @Inject(&#x27;HTTP_OPTIONS&#x27;) private httpClient: T) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Property-based-injection"><a href="#Property-based-injection" class="headerlink" title="Property-based injection"></a>Property-based injection</h2><p>지금까지 한것은 생성자에서 주입되기 때문에 constructor-based injection 이라고 부른다. 때때로 property-based injection 이 유용하다. 최상위 클래스가 여러 proivder 에 의존하는 경우 생성자 기반에 injection을 사용할경우 하위 클래스에서 super 를 사용하여 의존성을 주입해야 하는 귀찮은 경우가 생길 수 있다. 이럴땐 @Inject() 데코레이터를 사용해서 property-based injection을 사용하면 편리하다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Injectable, Inject &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class HttpService&lt;T&gt; &#123;</span><br><span class="line">  @Inject(&#x27;HTTP_OPTIONS&#x27;)</span><br><span class="line">  private readonly httpClient: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이런 경우를 제외한 대부분의 경우에서 constructor-based injection을 선호해야 한다. </p>
<h2 id="Provider-registration"><a href="#Provider-registration" class="headerlink" title="Provider registration"></a>Provider registration</h2><p>컨트롤러가 프로바이더를 소비할 수 있도록 모듈에 등록해 주어야 한다. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;</span><br><span class="line">import &#123; CatsController &#125; from &#x27;./cats/cats.controller&#x27;;</span><br><span class="line">import &#123; CatsService &#125; from &#x27;./cats/cats.service&#x27;;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line">export class AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/02/28/cleanCode/229228-%ED%95%A8%EC%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/28/cleanCode/229228-%ED%95%A8%EC%88%98/" class="post-title-link" itemprop="url">함수</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-28 09:08:03 / Modified: 09:08:07" itemprop="dateCreated datePublished" datetime="2022-02-28T09:08:03+09:00">2022-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cleanCode/" itemprop="url" rel="index"><span itemprop="name">cleanCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>함수를 잘 만드는법을 살펴본다. 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까? </p>
<h2 id="작게-만들어라"><a href="#작게-만들어라" class="headerlink" title="작게 만들어라"></a>작게 만들어라</h2><p>작은 함수가 좋다. 각 함수는 명백히 하나의 이야기를 표현해야 한다. </p>
<h3 id="블록과-들여쓰기"><a href="#블록과-들여쓰기" class="headerlink" title="블록과 들여쓰기"></a>블록과 들여쓰기</h3><p>블록 구조를 갖는 코드는 한줄 이어야 한다. 중첩 구조가 생길만큼 함수가 커져서는 안된다. 들여쓰기 수준을 1단이나 2단 정도로 유지한다. </p>
<h2 id="한가지만-해라"><a href="#한가지만-해라" class="headerlink" title="한가지만 해라"></a>한가지만 해라</h2><p>함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다. 함수를 판단할때 지정된 함수 이름 아래에서 추상화 수준을 판단한다. </p>
<p>함수를 만드는 이유는 큰 개념을 여러 단계로 나눠 수행하기 위해서이다. 추상화 수준이 둘 이상이라면 더 축소 가능할 수 있다. 따라서 한 가지만 하는지 판단하는 방법이 하나 더 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. </p>
<h2 id="함수당-추상화-수준은-하나로"><a href="#함수당-추상화-수준은-하나로" class="headerlink" title="함수당 추상화 수준은 하나로"></a>함수당 추상화 수준은 하나로</h2><p>함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수 내의 추상화 수준을 섞으면 코드를 읽는 사람이 근본 개념인지 세부사항인지 구분하기 어려워 진다. 이렇게 뒤섞기 시작하면 점점더 엉망이 된다. </p>
<h3 id="위에서-아래로-코드-읽기-내려가기-규칙"><a href="#위에서-아래로-코드-읽기-내려가기-규칙" class="headerlink" title="위에서 아래로 코드 읽기 : 내려가기 규칙"></a>위에서 아래로 코드 읽기 : 내려가기 규칙</h3><p>프로그램을 위에서 아래로 읽으면서 함수 추상화 수준이 한다계씩 낮아지게 작성해야 한다. TO 문단을 읽듯이 프로그램이 읽혀야 한다는 것인데 각 TO 문단은 이어지는 아래 단계의 TO 문단(~ 하려면) 을 참고한다. </p>
<p>ex ) </p>
<ul>
<li>TO 설정 페이지와 해제 페이지를 포함하려면, 설정 페이지를 포함하고, 테스트 페이지 내용을 포함하고, 해제 페이지를 포함한다.<ul>
<li>TO 설정 페이지를 포함하려면 , 슈트이면 슈트 설정 페이지를 포함한 후 일반 설정 페이지를 포함한다.</li>
<li>TO 슈트 설정 페이지를 포함하려면, 부모 계층에서 “SuiteSetUp” 페이지를 찾아 include 문과 페이지 경로를 추가한다.</li>
<li>TO 부모 계층을 검색하려면 …</li>
</ul>
</li>
</ul>
<p>위에서 아래로 TO 문단을 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다. </p>
<h2 id="Switch-문"><a href="#Switch-문" class="headerlink" title="Switch 문"></a>Switch 문</h2><p>Switch 문은 기본적으로 N가지를 처리하기 때문에 한가지 일만 하기 어렵다. 하지만 Switch 문을 사용하지 않을 수 도 없다. 하지만 각 switch 문을 저차원 클래스에 숨기고 절대 반복하지 않은 방법이 있다. </p>
<p>직원 유형에 따라 다른 값을 계산해 반환하는 함수이다. 좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function calculatePay(employee: Employee) &#123;</span><br><span class="line">  switch (employee.type) &#123;</span><br><span class="line">    case &#x27;COMMISSIONED&#x27;:</span><br><span class="line">      return calculateCommissionedPay(employee);</span><br><span class="line">    case &#x27;HOURLY&#x27;:</span><br><span class="line">      return calculateHourlyPay(employee);</span><br><span class="line">    case &#x27;SALARIED&#x27;:</span><br><span class="line">      return calculateSalariedPay(employee);</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(employee.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같은 문제가 있다.</p>
<ol>
<li>함수가 길다. 새 직원 유형을 추가하면 더 길어진다.</li>
<li>한가지 작업만 수행하지 않는다.</li>
<li>SRP(Single Responsibility Principle) 단일 책임 원칙을 위반한다. </li>
<li>OCP(Open Closed Principle): 개방 폐쇄 원칙을 위반한다. ( 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.) → 새 직원을 추가할때마다 코드를 변경해야 하기 때문이다. </li>
<li>가장 큰 문제는 위 함수와 구조가 동일한 함수가 무한정 존재한다는 사실이다. </li>
</ol>
<p>이문제를 해결하기 위해 switch 을 추상 팩토리(ABSTRACT FACTORY) 에 숨긴다. Switch 문을 통해 적절한 Employee 파생 클래스의 인스턴스를 생성한다. 여러가지 함수는 Employee 인터페이스를 거쳐 호출되게 한다. 그러면 다형성으로 인해 실제 파생 클래스의 함수가 실행된다.</p>
<p>좋은 예 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract class Employee &#123;</span><br><span class="line">  abstract isPayday(): boolean;</span><br><span class="line">  abstract calculatePay(): Money;</span><br><span class="line">  abstract deleverPay(pay: Money): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface EmployeeFactory &#123;</span><br><span class="line">  makeEmployee(record: EmployeeRecord): Employee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class EmployeeFactoryImpl implements EmployeeFactory &#123;</span><br><span class="line">  makeEmployee(record: EmployeeRecord): Employee &#123;</span><br><span class="line">    switch (record.type) &#123;</span><br><span class="line">      case &#x27;COMMISSIONED&#x27;:</span><br><span class="line">        return new CommissionedEmployee(record);</span><br><span class="line">      case &#x27;HOURLY&#x27;:</span><br><span class="line">        return new HourlEmployee(record);</span><br><span class="line">      case &#x27;SALARIED&#x27;:</span><br><span class="line">        return new SalariedEmployy(record);</span><br><span class="line">      default:</span><br><span class="line">        throw new Error(record.type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Siwtch 문을 다형적 객체를 생성하는 코드로 숨겨 버린다. </p>
<h2 id="서술적인-이름을-사용하라"><a href="#서술적인-이름을-사용하라" class="headerlink" title="서술적인 이름을 사용하라!"></a>서술적인 이름을 사용하라!</h2><p>길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 함수 이름만 보고 동작을 예측할수 있다면 좋은 코드라고 할수 있다. 단 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사 동사를 사용한다. includeSetupAndTeardownPages, IncludeSetupPages, includeSuiteSetuppage, includeSetupPage 등은 좋은 예이다. </p>
<h2 id="함수-인수"><a href="#함수-인수" class="headerlink" title="함수 인수"></a>함수 인수</h2><p>함수의 인수는 적을수록 좋다. 보통 2개 정도까진 괜찮고, 4개 이상부터는 특별한 이유가 필요하다. 인수가 있는것보다 인수가 없는것이 코드를 읽는사람이 이해하기 쉽다. 인수가 많아지면 테스트도 어렵다. 2개이상의 인수를 받는 함수를 테스트 하는것은 테스트를 어렵게 만든다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우이다. </p>
<h3 id="많이-쓰는-단항-형식"><a href="#많이-쓰는-단항-형식" class="headerlink" title="많이 쓰는 단항 형식"></a>많이 쓰는 단항 형식</h3><p>함수에 인수 1개를 넘기는 가장 흔한 경우는 두가지이다. </p>
<ol>
<li>인수에 질문을 던지는 경우이다. <code>fileExists(&quot;myfile&quot;): boolean</code> </li>
<li>인수를 뭔가로 변환해 결과를 반환하는 경우 <code>parseInt(&quot;2&quot;): number</code></li>
</ol>
<p>이 두경우는 독자가 당여하게 받아들인다. </p>
<h3 id="플래그-인수"><a href="#플래그-인수" class="headerlink" title="플래그 인수"></a>플래그 인수</h3><p>플래그 인수는 좋지 않다. 플래그 인수에 따라서 동작이 달라진 다는 의미가 함수에서 두가지를 한다는 의미이기 때문이다. 함수를 분리하는 것이 좋다. </p>
<p>redux 관련해서 작성했던 좋지 않은 예 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> export function fetchThunk&lt;T, I extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt;(</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;,</span><br><span class="line">  key: keyof I,</span><br><span class="line">  keep: boolean, // flag 인수</span><br><span class="line">  handler?: (state: I, action: PayloadAction&lt;T&gt;) =&gt; void, // handler fulfilled 이후에 </span><br><span class="line">) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [fetch.pending.type]: (state: I) =&gt; &#123;</span><br><span class="line">      state[key].loading = true;</span><br><span class="line">      state[key].data = keep ? state[key].data : null; // flag 인수에 사용</span><br><span class="line">      state[key].error = null;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.fulfilled.type]: (state: I, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].data = action.payload;</span><br><span class="line">      handler &amp;&amp; handler(state, action);</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.rejected.type]: (</span><br><span class="line">      state: I,</span><br><span class="line">      action: ReturnType&lt;typeof fetch.rejected&gt;,</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].error = action.error;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>keep : 이라는 flag 인수를 두어서 데이터를 유지할지 선택하였다.함수를 분리하고 이름도 더 길게 서술하도록 한다. </p>
<p>handler 를 받아서 fulfilled 이후에 실행할 함수를 콜백으로 받았는데 이또한  handler가 있는 함수와 핸들러가 없는 함수로 분리한다. </p>
<p>좋은 예 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">export function fetchDataKeepingPrev&lt;T, I extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt;(</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;,</span><br><span class="line">  key: keyof I,</span><br><span class="line">) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [fetch.pending.type]: (state: I) =&gt; &#123;</span><br><span class="line">      state[key].loading = true;</span><br><span class="line">      state[key].data = state[key].data // data kepp</span><br><span class="line">      state[key].error = null;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.fulfilled.type]: (state: I, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].data = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.rejected.type]: (</span><br><span class="line">      state: I,</span><br><span class="line">      action: ReturnType&lt;typeof fetch.rejected&gt;,</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].error = action.error;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function fetchData&lt;T, I extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt;(</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;,</span><br><span class="line">  key: keyof I,</span><br><span class="line">) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [fetch.pending.type]: (state: I) =&gt; &#123;</span><br><span class="line">      state[key].loading = true;</span><br><span class="line">      state[key].data = null // null </span><br><span class="line">      state[key].error = null;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.fulfilled.type]: (state: I, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].data = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.rejected.type]: (</span><br><span class="line">      state: I,</span><br><span class="line">      action: ReturnType&lt;typeof fetch.rejected&gt;,</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].error = action.error;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function fetchDataKeepingPrevWithHandler&lt;T, I extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt;(</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;,</span><br><span class="line">  key: keyof I,</span><br><span class="line">	handler?: (state: I, action: PayloadAction&lt;T&gt;) =&gt; void,</span><br><span class="line">) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [fetch.pending.type]: (state: I) =&gt; &#123;</span><br><span class="line">      state[key].loading = true;</span><br><span class="line">      state[key].data = state[key].data // data kepp</span><br><span class="line">      state[key].error = null;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.fulfilled.type]: (state: I, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].data = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.rejected.type]: (</span><br><span class="line">      state: I,</span><br><span class="line">      action: ReturnType&lt;typeof fetch.rejected&gt;,</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].error = action.error;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function fetchDataWithHandler&lt;T, I extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt;(</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;,</span><br><span class="line">  key: keyof I,</span><br><span class="line">	handler?: (state: I, action: PayloadAction&lt;T&gt;) =&gt; void,</span><br><span class="line">) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [fetch.pending.type]: (state: I) =&gt; &#123;</span><br><span class="line">      state[key].loading = true;</span><br><span class="line">      state[key].data = null // null</span><br><span class="line">      state[key].error = null;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.fulfilled.type]: (state: I, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].data = action.payload;</span><br><span class="line">    &#125;,</span><br><span class="line">    [fetch.rejected.type]: (</span><br><span class="line">      state: I,</span><br><span class="line">      action: ReturnType&lt;typeof fetch.rejected&gt;,</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      state[key].loading = false;</span><br><span class="line">      state[key].error = action.error;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 이렇게 작성하니 인수를 줄이기 위해서 중복된 함수가 너무 많아진 느낌이다. 함수를 작성하는 쪽에 수고로움과 사용하는 쪽에서에 편리함 중에 선택해야 하는 문제 같다. </p>
<p>추가적으로 인수를 더 줄이기 위해서 FetchThunkData 라는 클래스를 만들어 key, fetch, keep 정도는 생성자에서 받아올 수 있을거 같다. 이렇게 하면 인스턴스에 이름으로 데이터를 유지할지를 명시하면 사용하는쪽에서 헷갈리지도 않고 함수도 중복되게 적지 않아도 될거 같다. </p>
<p>개인적으로 생각한 예 : ❇️ <code>FetchThunkData</code> class</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">type FetchThunkDataConstructor&lt;T, S&gt; = &#123;</span><br><span class="line">  fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;;</span><br><span class="line">  keep: boolean;</span><br><span class="line">  key: string;</span><br><span class="line">  handler?: (state: S, action: PayloadAction&lt;T&gt;) =&gt; void;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export class FetchThunkData&lt;T, S extends &#123;[key: string]: InitialState&lt;T&gt;&#125;&gt; &#123;</span><br><span class="line">  private fetch: AsyncThunk&lt;T, string, &#123;&#125;&gt;;</span><br><span class="line">  private keep: boolean;</span><br><span class="line">  private key: string;</span><br><span class="line">  private handler?: (state: S, action: PayloadAction&lt;T&gt;) =&gt; void;</span><br><span class="line"></span><br><span class="line">  constructor(&#123;fetch, keep, key, handler&#125;: FetchThunkDataConstructor&lt;T, S&gt;) &#123;</span><br><span class="line">    this.fetch = fetch;</span><br><span class="line">    this.keep = keep;</span><br><span class="line">    this.key = key;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private pendingReducer = (state: S) =&gt; &#123;</span><br><span class="line">    state[this.key].data = this.keep ? state[this.key].data : null;</span><br><span class="line">    state[this.key].loading = true;</span><br><span class="line">    state[this.key].error = null;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private fuflledReducer = (state: S, action: PayloadAction&lt;T&gt;) =&gt; &#123;</span><br><span class="line">    state[this.key].loading = false;</span><br><span class="line">    state[this.key].data = action.payload;</span><br><span class="line">    this.handler &amp;&amp; this.handler(state, action);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  private rejectedReducer = (</span><br><span class="line">    state: S,</span><br><span class="line">    action: ReturnType&lt;typeof this.fetch.rejected&gt;,</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    state[this.key].loading = false;</span><br><span class="line">    state[this.key].error = action.error;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  getFetchThunkReducer() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      [this.fetch.pending.type]: this.pendingReducer,</span><br><span class="line">      [this.fetch.fulfilled.type]: this.fuflledReducer,</span><br><span class="line">      [this.fetch.rejected.type]: this.rejectedReducer,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>사용하는 부분 : </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fetchThunkKeepDataNoHandler = new FetchThunkData(&#123;</span><br><span class="line">  fetch: fetchChallenges,</span><br><span class="line">  keep: true,</span><br><span class="line">  key: &#x27;challenges&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const challengesSlice = createSlice(&#123;</span><br><span class="line">  name: &#x27;challenges&#x27;,</span><br><span class="line">  initialState,</span><br><span class="line">  reducers: &#123;&#125;,</span><br><span class="line">  extraReducers: fetchThunkKeepDataNoHandler.getFetchThunkReducer(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fetchThunkKeepDataNoHandler</code> 라른 인스턴스에 이름이 있기 때문에 data를 유지하하고 handler 가 없는 reducer를 반환함을 알 수 있다. </p>
<p>또한, 생성자에서 필요한 인수를 받았기 때문에 <code>getFetchThunkReducer</code> 에서는 인수를 받지 않아도 된다. </p>
<h3 id="이항-함수"><a href="#이항-함수" class="headerlink" title="이항 함수"></a>이항 함수</h3><p>이항 함수는 함수에 인자로 2개를 받는 함수이다. 2개의 인수가 한개의 값을 표현하기에 적합하거나, 자연적인 순서가 있는것이 아니라면 인자로 2개를 받는것은 1개를 받는것보다 이해하기 어렵다 (자연스러운 경우 ? <code>new Point(x, y)</code> 같은 경우, 인자 2개가 하나의 표인트를 표현하는것과 순서도 자연스럽다)</p>
<p>인수가 2개인 경우가 반드시 나쁜 경우는 아니지만 줄일수 있도록 해야한다. 예를들어서 <code>writeField(outpurStream, name)</code> 인자에 순서를 기억하기 어렵기 때문에 <code>writeField(name)</code> 으로 줄이면 좋다. 이럴 경우에는 <code>OutputStream</code> 이라는 클래스를 만들고 멤버 변수로 <code>outputStrem</code> 을 갖고, <code>writeField(name)</code> 메서드를 구현하여 <code>outputStream.writeField(name)</code> 같이 호출할 수 있다. </p>
<h3 id="삼항-함수"><a href="#삼항-함수" class="headerlink" title="삼항 함수"></a>삼항 함수</h3><p>인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 삼항 함수를 만들 때는 신중히 고려해야 한다.</p>
<h3 id="인수-객체"><a href="#인수-객체" class="headerlink" title="인수 객체"></a>인수 객체</h3><p>인수가 2-3 개 필요하다면 일부로 독자적인 클래스 변수로 선언할 가능성을 짚어봐야 한다. </p>
<p>좋지 않은 예 : ❌</p>
<p><code>makeCircle(x: number, y: number, radius: number)</code></p>
<p>좋은 예 : ✅</p>
<p><code>makeCircle(center: Point, radius: number)</code></p>
<p>인수로 객체를 넘기는 것이 눈속임 이라 생각할 수 있지만, 객체에는 이름을 담기 때문에 결국엔 어떤 개념을 전달하게 된다.그것이 코드를 읽는 사람들에게 이해하는데 더 큰 도움을 준다. </p>
<p>자바스크립트에서 함수에 인수로 객체를 받으면 인수에 개념을 전달할수 있게됨으로 인수를 객체로 전달하도록 하는것이 좋다.</p>
<h3 id="인수-목록"><a href="#인수-목록" class="headerlink" title="인수 목록"></a>인수 목록</h3><p>때로는 인수 개수가 가변적인 함수도 필요하다. 가변적인 인수를 갖는 함수는 사실상 2개의 인수를 받는 이항함수로 생각할 수 있다. <code>function sumFunction(arg1, ...argList)</code> </p>
<h3 id="동사와-키워드"><a href="#동사와-키워드" class="headerlink" title="동사와 키워드"></a>동사와 키워드</h3><p>함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필요하다. <code>write(name)</code> 함수는 곧바로 이해가 되는데 이름이 무엇이든 쓴다는 뜻으로 생각할 수 있기 때문이다. 더 나은 이름으로는 <code>wirteField(name)</code> 과 같이 사용할 수 있다. </p>
<p>또는, 함수 이름에 키워드를 추가하는 방식을 사용할 수 있다. 이렇게 하면 인수에 순서를 기억할 필요 없이 함수에 이름으로 알 수 있게 된다. </p>
<h2 id="부수-효과를-일으키지-마라"><a href="#부수-효과를-일으키지-마라" class="headerlink" title="부수 효과를 일으키지 마라."></a>부수 효과를 일으키지 마라.</h2><p>함수에서 부수효과가 일어나면 한가이 일을 하겠다고 한 함수가 사실은 그렇지 못한 것이 된다. </p>
<p>안 좋은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class UserValidator &#123;</span><br><span class="line">  private cryptographer: Cryptographer;</span><br><span class="line"></span><br><span class="line">  constructor(cryptographer: Cryptographer) &#123;</span><br><span class="line">    this.cryptographer = cryptographer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  checkPassword(userName: string, password: string): boolean &#123;</span><br><span class="line">    const user: User = UserGatewayImpl.findByName(userName);</span><br><span class="line">    if (user !== null) &#123;</span><br><span class="line">      const codePhrase = user.getPhraseEncodedByPassword();</span><br><span class="line">      const phrase = this.cryptographer.decrypt(codePhrase, password);</span><br><span class="line">      if (phrase === &#x27;Valid Password&#x27;) &#123;</span><br><span class="line">        Session.initialize();</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checkPassword</code> 가 패스워드를 확인해서 boolean 값을 반환한다고 생각하지만 실제로 안에서는 세션을 초기화 하는 일까지 하고 있는 것이다. 이럴경우 이름을 <code>checkPasswordAndSessionIntialize</code> 라고 바꾸는 것이 좋다. 그래도 합수가 한가지 일을 하게 한다는 원칙은 어긋나지만</p>
<h3 id="부수효과-피하기"><a href="#부수효과-피하기" class="headerlink" title="부수효과 피하기"></a>부수효과 피하기</h3><p>사이드 이펙트를 일으키지 않기 위해서는 객체를 그대로 사용하는 것이 아니라 객체를 복사해서 새로운 객체를 만들고 변경하는 방법을 사용해야 한다. 또한 전역 변수를 변경시켜 전역 변수를 사용하는 다른 함수에 영향을 주면 안된다.</p>
<h3 id="명령과-조회를-분리하라"><a href="#명령과-조회를-분리하라" class="headerlink" title="명령과 조회를 분리하라"></a>명령과 조회를 분리하라</h3><p>함수는 뭔가를 수행하거 답하거나 둘 중 하나만 해야한다. 둘다 하면 혼란을 초래한다.</p>
<p>좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function set(attribute: string, value: string): boolean &#123;</span><br><span class="line">  //...</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (set(&#x27;name&#x27;, &#x27;koo&#x27;)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>작성한 함수는 객체에 속성에 지정한 value 로 설정하면 true 를 실패하면 false를 반환하는 함수이다. 그러나 if 문 안에 들어가면 해석이 다양해진다. 개발자는 동사로서 설정하라고 판단하고 함수를 작성했지만 사용하는 쪽에서는 설정되어 있다면으로 해석할 수 있다. 함수 선언부를 확인하고 나서야 객체에 설정하는 함수구나 생각하기 쉽상이다. 따라서 설정 되어 있다면을 함수로 따로 분리하는 것이 현명하다. </p>
<p>좋은 예시 :  ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (attrubuteExist(&#x27;name&#x27;)) &#123;</span><br><span class="line">  setAttribute(&#x27;name&#x27;, &#x27;koo&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>값을 설정하는 함수, 반환하는 함수를 분리하면 읽는 쪽에서 코드를 더 쉽게 이해할 수 있다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://jayoonkoo.github.io/2022/02/01/cleanCode/220201-220201%20%EC%9D%98%EB%AF%B8%20%EC%9E%88%EB%8A%94%20%EC%9D%B4%EB%A6%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JayoonKoo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="티끌모아 태산">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/01/cleanCode/220201-220201%20%EC%9D%98%EB%AF%B8%20%EC%9E%88%EB%8A%94%20%EC%9D%B4%EB%A6%84/" class="post-title-link" itemprop="url">220201 의미 있는 이름</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-01 16:07:55 / Modified: 16:08:03" itemprop="dateCreated datePublished" datetime="2022-02-01T16:07:55+09:00">2022-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cleanCode/" itemprop="url" rel="index"><span itemprop="name">cleanCode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-의미-있는-이름"><a href="#2-의미-있는-이름" class="headerlink" title="2. 의미 있는 이름"></a>2. 의미 있는 이름</h1><p>클린 코드를 읽고 공부한 내용을 타입스크립트로 정리해본 내용입니다. 개인적으로 공부한 내용이라 틀린점도 있을 수 있습니다. </p>
<h2 id="의도를-분명히-밝혀라"><a href="#의도를-분명히-밝혀라" class="headerlink" title="의도를 분명히 밝혀라"></a>의도를 분명히 밝혀라</h2><p>변수나 함수 그리고 클래스의 이름은 다음과 같은 굵직한 질문에 모두 답해야 한다. 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못햇다는 말이다. </p>
<p><code>const d: number</code> ❌</p>
<p><code>const daysSinceCreation: number</code> ✅</p>
<p>코드의 함축되어 있는 정보를 독자로 하여금 이해할 수 있도록 명시적으로 이름을 지어야 한다. </p>
<p>좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getThem() &#123;</span><br><span class="line">	const list1: number[] = []</span><br><span class="line">	for (let x of theList) &#123;</span><br><span class="line">		if (x[0] === 4) &#123;</span><br><span class="line">			list1.push(x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return list1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>드러나지 않은 함축적인 정보는 다음과 같다.</p>
<ol>
<li>theList에 무엇이 들어있는가?</li>
<li>theList 에서 0 번째 값이 어째서 중요한가?</li>
<li>값 4는 무슨 의미인가?</li>
<li>함수가 반환하는 리스트 list1을 어떻게 사용하는가? </li>
</ol>
<p>만약 해당 함수가 지뢰찾기에서 깃발이 꽂힌 상태에 cell를 반환하는 함수라고 생각한다면 함축적인 의미를 이름을 통해서 명시적으로 드러낼 수 있다. </p>
<p>좋은 예시 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export interface Cell &#123;</span><br><span class="line">  isFlagged: () =&gt; boolean;</span><br><span class="line">  data: number[];</span><br><span class="line">&#125;</span><br><span class="line">const FLAGGED_STATE = 4;</span><br><span class="line">class CellImpl implements Cell &#123;</span><br><span class="line">  data: number[] = [0];</span><br><span class="line">  constructor(flaggedState: number) &#123;</span><br><span class="line">    this.data[0] = flaggedState;</span><br><span class="line">  &#125;</span><br><span class="line">  isFlagged = () =&gt; &#123;</span><br><span class="line">    return this.data[0] === FLAGGED_STATE;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const gameBoard: Cell[] = [new CellImpl(FLAGGED_STATE)];</span><br><span class="line">function getFlaggedCells() &#123;</span><br><span class="line">  const flaggedCells: Cell[] = [];</span><br><span class="line">  for (let cell of gameBoard) &#123;</span><br><span class="line">    if (cell.isFlagged()) &#123;</span><br><span class="line">      flaggedCells.push(cell);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>theLIst 가 gameBoard 로 무엇이 들어가 있느지 알수 있게 되었다.</li>
<li>theList 에 0번째 값은 칸 상태, 값 4는 깃발이 꽂힌 상태라는 의미인데 <code>cell.isFlagged()</code> 로 명확하게 표현할 수 있게 되었다.</li>
<li>함수가 반환하는 리스트 list1 은 깃발이 꽂힌 상태에 cell 이라는 flaggedCells 이름으로 명확해진다.</li>
</ol>
<h2 id="그릇된-정보를-피하라"><a href="#그릇된-정보를-피하라" class="headerlink" title="그릇된 정보를 피하라"></a>그릇된 정보를 피하라</h2><p>이름으로 잘못된 정보를 주어서는 안된다. </p>
<ol>
<li>널리쓰이는 의미가 있는 단어를 다른 의미로 사용하지 말것</li>
<li>특수한 의미에 단어를 의미에 맞게 사용할것 (List 를 사용할 경우 List인 경우에만 사용할것 아니라면 accountGroup 이나 accounts 가 낫다)</li>
<li>서로 흡사한 이름을 사용하지 말것 </li>
<li>유사한 개념은 유사한 표기법을 사용할것 (일관성 유지)</li>
</ol>
<h2 id="의미-있게-구분하라"><a href="#의미-있게-구분하라" class="headerlink" title="의미 있게 구분하라"></a>의미 있게 구분하라</h2><p>이름이 달라야 한다면 의미도 달라져야 한다. (a1, a2) 와 같은 구분에 변수는 아무런 의미도 전달하지 못한다.</p>
<p>불용어를 남용 하지 말아야 한다. ProudctInfo 나 ProductData 에서 Info 나 Data 는 명확한 구분이 되지 못하고 영어에서 a, an, the와 같이 사용될 뿐이다. 접두어를 사용하지 말란 의미가 아니라 접두어를 사용하여 구분하는 의미가 있어야 한다는 것이다. </p>
<p>NameString 과 Name 은 차이가 없다. Customer 와 CustomerObject 도 마찬가지이다. </p>
<p>읽는 사람이 차이를 알도록 이름을 지어야 한다. </p>
<h2 id="발음하기-쉬운-이름을-사용하라"><a href="#발음하기-쉬운-이름을-사용하라" class="headerlink" title="발음하기 쉬운 이름을 사용하라"></a>발음하기 쉬운 이름을 사용하라</h2><p>발음하기 쉬운 단어를 사용해야 지적인 대화가 가능해집니다.</p>
<p>좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class DtaRcrd102 &#123;</span><br><span class="line">  private genymdhms: Date;</span><br><span class="line">  private modymdhms: Date;</span><br><span class="line">  private readonly pszqint = &#x27;102&#x27;;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>발음하기 쉬운 단어를 사용한 좋은 예시 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">  private generationTimestamp: Date;</span><br><span class="line">  private modificationTimestamp: Date;</span><br><span class="line">  private readonly recordId = &#x27;102&#x27;;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="검색하기-쉬운-이름을-사용하라"><a href="#검색하기-쉬운-이름을-사용하라" class="headerlink" title="검색하기 쉬운 이름을 사용하라"></a>검색하기 쉬운 이름을 사용하라</h2><p>긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다. 이름 길이는 범위 크기에 비례해야 한다. </p>
<p>좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = 0;</span><br><span class="line">const t: number[] = [];</span><br><span class="line">for (let j = 0; j &lt; 34; j++) &#123;</span><br><span class="line">  s += (t[j] * 4) / 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좋은 예시 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const NUMBER_OF_TASKS = 34;</span><br><span class="line">const realDaysPerIdealDay = 4;</span><br><span class="line">const WORK_DAYS_PER_WEEK = 5;</span><br><span class="line">let sum = 0;</span><br><span class="line">const taskEstimate: number[] = [];</span><br><span class="line">for (let j = 0; j &lt; NUMBER_OF_TASKS; j++) &#123;</span><br><span class="line">  const realTaskDays = taskEstimate[j] * realDaysPerIdealDay;</span><br><span class="line">  const realTaskWeeks = realTaskDays / WORK_DAYS_PER_WEEK;</span><br><span class="line">  sum += realTaskWeeks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WORK_DAYS_PER_WEEK</code> 을 단순히 5라고 하였을때 문제가 생겨 변경해야 한다면 5로 검색하기는 쉽지 않을 것이다. 그러나 <code>WORK_DAYS_PER_WEEK</code> 으로 명시했을 경우 쉽게 검색할 수 있다. </p>
<h2 id="인코딩을-피하라"><a href="#인코딩을-피하라" class="headerlink" title="인코딩을 피하라"></a>인코딩을 피하라</h2><p>인코딩한 이름은 발음하기 어려우며 오타가 생기기도 쉽다. </p>
<h3 id="헝가리식-표기법"><a href="#헝가리식-표기법" class="headerlink" title="헝가리식 표기법"></a>헝가리식 표기법</h3><p>과거에는 타입을 컴파일러가 검사하지 못했기 때문에 접두어에 짧은 문자를 더해서 타입을 표현하곤 했다. 요즘에 언어들은 컴파일러가 타입을 강제하고 기억하고 있기 때문에 이렇게 하는것이 오히려 방해가 되기도 한다. 또한 타입에 변환을 어렵게 한다. phoneNumber 를 string으로 타입을 바꾸어도 여전히 이름은 phoneNumber 이기 때문에 타입을 오해하기도 쉽다. </p>
<h3 id="멤버-변수-접두어"><a href="#멤버-변수-접두어" class="headerlink" title="멤버 변수 접두어"></a>멤버 변수 접두어</h3><p>멤버 변수에 <code>m_</code> 와 같은 접두어를 붙힐 필요도 없다. </p>
<h3 id="인터페이스-클래스와-구현-클래스"><a href="#인터페이스-클래스와-구현-클래스" class="headerlink" title="인터페이스 클래스와 구현 클래스"></a>인터페이스 클래스와 구현 클래스</h3><p>인터페이스와 구현 클래스를 구분하기 위해 인코딩이 필요하기도 하다. 과거에는 인터페이스에 <code>IShapeFactory</code> , 구현 클래스에 <code>ShapeFactory</code> 와 같은 방식으로 <code>I</code> 를 붙히기도 했는데 과도한 정보를 주는 느낌도 있어서 인터페이스를 <code>ShapeFactory</code> 와 같이 쓰고 구현체를 <code>ShapeFactoryImpl</code> 과 같이 사용하는것을 추천한다.</p>
<h2 id="자신의-기억력을-자랑하지-마라"><a href="#자신의-기억력을-자랑하지-마라" class="headerlink" title="자신의 기억력을 자랑하지 마라."></a>자신의 기억력을 자랑하지 마라.</h2><p>변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름은 바람직하지 못하다. </p>
<p>문자 하나만 사용하는것도 루프와 같이 짧은 범위 내에서 사용하는것을 제외하면 바람직하지 못하다. 나중에 무슨 의미였는지 기억하기 어렵다. </p>
<p>기억하기 쉬운 명로함이 최고임을 기억해라 </p>
<h2 id="클래스-이름"><a href="#클래스-이름" class="headerlink" title="클래스 이름"></a>클래스 이름</h2><p>클래스 이름이나 객체 이름은 명사나 명사구가 적절하다. Customer, AddressParser 은 좋은 예이다. Manager, Precessor, Data, Info 등과 같은 단어는 피하고 동사는 사용하지 않는다.</p>
<h2 id="메서드-이름"><a href="#메서드-이름" class="headerlink" title="메서드 이름"></a>메서드 이름</h2><p>메서드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등은 적합하다. </p>
<h2 id="기발한-이름은-피하라"><a href="#기발한-이름은-피하라" class="headerlink" title="기발한 이름은 피하라"></a>기발한 이름은 피하라</h2><p>재미난 이름보다는 명로한 이름을 선택하라</p>
<h2 id="한-개념에-한-단어를-사용하라"><a href="#한-개념에-한-단어를-사용하라" class="headerlink" title="한 개념에 한 단어를 사용하라"></a>한 개념에 한 단어를 사용하라</h2><p>추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. 예를 들어 똑같은 메서드를 클래스마다 fetch, retrieve, get 으로 제각각 부르면 혼란스럽다. 메서드 이름은 독자적이고 일관적이어야 한다. </p>
<p>이름이 다르면 독자는 당연히 클래스도 다르고 타입도 다르다고 생각한다. 예를들어 DeviceManager와 ProtocolController이 근본적으로 하는일이 똑같다면 하나로 통일시켜야 한다. </p>
<h2 id="말장난을-하지-마라"><a href="#말장난을-하지-마라" class="headerlink" title="말장난을 하지 마라"></a>말장난을 하지 마라</h2><p>한 단어를 두가지 목적으로 사용하지 말아야 한다. </p>
<p>맥락이 같다면 중복하여 사용해도 되지만 맥락이 다르다면 다른 단어를 사용해야 한다. 예를들어 클래스에 add 라는 메서드를 추가한다고 생각해 보자 어떤 매개변수 두개를 받아서 두개를 조합해 새로운 값을 반환하는 맥락이라면 여러 클래스에서 add 라는 이름에 메서드를 동일하게 사용해도 된다. 그런데 어떤 클래스에서는 어떤 값을 받아서 리스트에 더하는 메서드를 추가한다고 생각해보자. 이럴 경우 add 라는 단어를 사용하는것이 적합할까? 이럴 경우는 앞에서와 맥락이 다르므로 다른 메서드 이름을 사용해야 한다. 이 경우 insert 나 append 가 적합해 보인다. </p>
<h2 id="해법-영역에서-가져온-이름을-사용하라"><a href="#해법-영역에서-가져온-이름을-사용하라" class="headerlink" title="해법 영역에서 가져온 이름을 사용하라"></a>해법 영역에서 가져온 이름을 사용하라</h2><p>코드를 읽는 사람도 프로그래머 임을 기억해라. 프로그래머에게 익숙학 기술 개념은 아주 많으며 해당 개념 용어를 사용하는 것은 이해 관점에서도 아주 바람직하다. VISITOR 패턴에 친숙한 프로그래머는 AccountVisitor 라는 이름을 금방 이해할 것이다. </p>
<h2 id="문제-영역에서-가져온-이름을-사용하라"><a href="#문제-영역에서-가져온-이름을-사용하라" class="headerlink" title="문제 영역에서 가져온 이름을 사용하라"></a>문제 영역에서 가져온 이름을 사용하라</h2><p>적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져온다. </p>
<h2 id="의미-있는-맥락을-추가하라"><a href="#의미-있는-맥락을-추가하라" class="headerlink" title="의미 있는 맥락을 추가하라"></a>의미 있는 맥락을 추가하라</h2><p>클래스, 함수, 이름 공간에 넣어 맥락을 부여한다. 모든 방법이 실패하면 마지막 수단으로 접두어를 붙인다. 예를 들어서 firstName, lastName, street, state, zipcode .. 와 같은 변수를 사용한다면 주소라는 사실을 금방 알아챈다. 하지만 state 라는 변수 하나만 매개변수로 사용한다면 주소에 일부분이라고 생각할 수 있을까? 좀 더 큰 구조(주소) 에 속한다는 것을 명시하기 위해서 addr 이라는 접두어를 사용할 수 있다. addrFirstName, addrState…</p>
<p>또는, 맥락에 맞는 클래스를 생성하는것이 더 도움이 된다. 예를 들어 밑에 나오는 코드에서 num, verb, pluraModifier 는 통계 추측에 사용되는 변수이다. 단순히 사용되기만 한다면 어디에 사용되는 변수인지 코드를 다 읽지 않고서는 예측하기 힘들다. 이때 GuessStaticMessage 라는 클래스를 만들어 해당 변수를 멤버변수로 포함시킨다면 맥락을 더해서 어디에 사용되는 변수인지 명확히 표현할 수 있다. </p>
<p>좋지 않은 예시 : ❌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function printGuessStatistics(candidate: string, count: number) &#123;</span><br><span class="line">  let num: string;</span><br><span class="line">  let verb: string;</span><br><span class="line">  let pluralModifier: string;</span><br><span class="line"></span><br><span class="line">  if (count === 0) &#123;</span><br><span class="line">    num = &#x27;no&#x27;;</span><br><span class="line">    verb = &#x27;are&#x27;;</span><br><span class="line">    pluralModifier = &#x27;s&#x27;;</span><br><span class="line">  &#125; else if (count === 1) &#123;</span><br><span class="line">    num = &#x27;1&#x27;;</span><br><span class="line">    verb = &#x27;is&#x27;;</span><br><span class="line">    pluralModifier = &#x27;&#x27;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    num = String(count);</span><br><span class="line">    verb = &#x27;are&#x27;;</span><br><span class="line">    pluralModifier = &#x27;s&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const guessMessage = `There $&#123;verb&#125; $&#123;num&#125; $&#123;candidate&#125;$&#123;pluralModifier&#125;`;</span><br><span class="line">  console.log(guessMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>좋은 예시 : ✅</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class GuessStatisticsMessage &#123;</span><br><span class="line">  private num: string = &#x27;&#x27;;</span><br><span class="line">  private verb: string = &#x27;&#x27;;</span><br><span class="line">  private pluralModifier: string = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">  make(candidate: string, count: number) &#123;</span><br><span class="line">    this.createPluralDependentMessageParts(count);</span><br><span class="line">    return `There $&#123;this.verb&#125; $&#123;this.num&#125; $&#123;candidate&#125;$&#123;this.pluralModifier&#125;`;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private createPluralDependentMessageParts(count: number) &#123;</span><br><span class="line">    if (count === 0) &#123;</span><br><span class="line">      this.thereAreNoLetters();</span><br><span class="line">    &#125; else if (count === 1) &#123;</span><br><span class="line">      this.thereIsOneLetter();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.thereAreManyLetters(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private thereAreManyLetters(count: number) &#123;</span><br><span class="line">    this.num = String(count);</span><br><span class="line">    this.verb = &#x27;are&#x27;;</span><br><span class="line">    this.pluralModifier = &#x27;s&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private thereIsOneLetter() &#123;</span><br><span class="line">    this.num = &#x27;1&#x27;;</span><br><span class="line">    this.verb = &#x27;is&#x27;;</span><br><span class="line">    this.pluralModifier = &#x27;&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private thereAreNoLetters() &#123;</span><br><span class="line">    this.num = &#x27;no&#x27;;</span><br><span class="line">    this.verb = &#x27;are&#x27;;</span><br><span class="line">    this.pluralModifier = &#x27;s&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>num, verb, pluralModifier 가 GuessStatisticMessage 클래스 안에 있으므로 맥락상 통계 메세지를 만드는데 사용되는 멤버 변수란 것을 알게 된다. </p>
<h2 id="불필요한-맥락을-없애라"><a href="#불필요한-맥락을-없애라" class="headerlink" title="불필요한 맥락을 없애라"></a>불필요한 맥락을 없애라</h2><p>불필요한 맥락은 없애야 한다. 예를들어 고급 휘발유 충전소 라는 애플리케이션을 짠다고 했을때, 모든 클래스에 GSD 접두어를 붙히는 것은 바람직하지 못하다. </p>
<p>일반적으로 의미가 분명하다면 짧은 이름이 긴 이름보다 좋다. accountAddress 와 customerAddress 는 Address 클래스 인스턴스로는 적합하나 클래스 이름으로는 부적합하다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JayoonKoo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
